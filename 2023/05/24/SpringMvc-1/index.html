<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>SpringMvc | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="SpringMvc架构Servlet 只能接收请求，产生响应，不能做真正的数据处理   把Servlet拆分成三层架构 由Web负责页面数据的收集、产生页面、返回页面 由service进行业务处理，数据处理 由Dao负责数据持久化、查询数据  Mvc模式(Model And View) 将Servlet拆分成三块 请求到达Controller、然后到Service处理、dao处理，最终把结果返回到">
<meta property="og:type" content="article">
<meta property="og:title" content="SpringMvc">
<meta property="og:url" content="http://example.com/2023/05/24/SpringMvc-1/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="SpringMvc架构Servlet 只能接收请求，产生响应，不能做真正的数据处理   把Servlet拆分成三层架构 由Web负责页面数据的收集、产生页面、返回页面 由service进行业务处理，数据处理 由Dao负责数据持久化、查询数据  Mvc模式(Model And View) 将Servlet拆分成三块 请求到达Controller、然后到Service处理、dao处理，最终把结果返回到">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="c:\Users\26411\AppData\Roaming\Typora\typora-user-images\image-20230409130350109.png">
<meta property="og:image" content="c:\Users\26411\AppData\Roaming\Typora\typora-user-images\image-20230409130627948.png">
<meta property="og:image" content="c:\Users\26411\AppData\Roaming\Typora\typora-user-images\image-20230409130827288.png">
<meta property="og:image" content="c:\Users\26411\AppData\Roaming\Typora\typora-user-images\image-20230409131139989.png">
<meta property="og:image" content="c:\Users\26411\AppData\Roaming\Typora\typora-user-images\image-20230409122344707.png">
<meta property="og:image" content="c:\Users\26411\AppData\Roaming\Typora\typora-user-images\image-20230409123428191.png">
<meta property="og:image" content="c:\Users\26411\AppData\Roaming\Typora\typora-user-images\image-20230410191703666.png">
<meta property="og:image" content="c:\Users\26411\AppData\Roaming\Typora\typora-user-images\image-20230424154114347.png">
<meta property="og:image" content="c:\Users\26411\AppData\Roaming\Typora\typora-user-images\image-20230424182152842.png">
<meta property="og:image" content="c:\Users\26411\AppData\Roaming\Typora\typora-user-images\image-20230424182505317.png">
<meta property="og:image" content="c:\Users\26411\AppData\Roaming\Typora\typora-user-images\image-20230424184429159.png">
<meta property="og:image" content="c:\Users\26411\AppData\Roaming\Typora\typora-user-images\image-20230424192743134.png">
<meta property="article:published_time" content="2023-05-24T05:07:50.000Z">
<meta property="article:modified_time" content="2023-05-24T05:10:00.988Z">
<meta property="article:author" content="HuangWeiGuo">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:\Users\26411\AppData\Roaming\Typora\typora-user-images\image-20230409130350109.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-SpringMvc-1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/24/SpringMvc-1/" class="article-date">
  <time class="dt-published" datetime="2023-05-24T05:07:50.000Z" itemprop="datePublished">2023-05-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      SpringMvc
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="SpringMvc架构"><a href="#SpringMvc架构" class="headerlink" title="SpringMvc架构"></a>SpringMvc架构</h1><p>Servlet 只能接收请求，产生响应，不能做真正的数据处理</p>
<img src="C:\Users\26411\AppData\Roaming\Typora\typora-user-images\image-20230409130350109.png" alt="image-20230409130350109" style="zoom:50%;" />

<p>把Servlet拆分成三层架构</p>
<p>由Web负责页面数据的收集、产生页面、返回页面</p>
<p>由service进行业务处理，数据处理</p>
<p>由Dao负责数据持久化、查询数据</p>
<p><img src="C:\Users\26411\AppData\Roaming\Typora\typora-user-images\image-20230409130627948.png" alt="image-20230409130627948"></p>
<p>Mvc模式(Model And View)</p>
<p>将Servlet拆分成三块 请求到达Controller、然后到Service处理、dao处理，最终把结果返回到Controller</p>
<p>结果就是Model，把页面抽取出来形成View， View+Model就是真正的页面返回给浏览器    View通常使用jsp技术</p>
<p><img src="C:\Users\26411\AppData\Roaming\Typora\typora-user-images\image-20230409130827288.png" alt="image-20230409130827288"></p>
<p>现在的开发又变了—-异步调用  </p>
<p>View发生了变化，前端使用HTML、CSS、Vue</p>
<p>而后端处理后形成的Model转成json再返回给前端</p>
<p>前端组织页面和数据形成真正的页面</p>
<p><img src="C:\Users\26411\AppData\Roaming\Typora\typora-user-images\image-20230409131139989.png" alt="image-20230409131139989"></p>
<h1 id="SpringMvc执行流程"><a href="#SpringMvc执行流程" class="headerlink" title="SpringMvc执行流程"></a>SpringMvc执行流程</h1><h1 id="几个概念："><a href="#几个概念：" class="headerlink" title="几个概念："></a>几个概念：</h1><p>1、DispatcherServlet		中央控制器</p>
<p>2、Handler 		处理器</p>
<p>3、HandlerMapping  处理器映射器</p>
<p>4、HandlerAdapter   处理器适配器</p>
<p>5、ViewResolver   视图解析器</p>
<h1 id="SpringMvc一次执行的图解流程"><a href="#SpringMvc一次执行的图解流程" class="headerlink" title="SpringMvc一次执行的图解流程"></a>SpringMvc一次执行的图解流程</h1><p><img src="C:\Users\26411\AppData\Roaming\Typora\typora-user-images\image-20230409122344707.png" alt="image-20230409122344707"></p>
<h1 id="SpringMvc一次执行的文字版流程"><a href="#SpringMvc一次执行的文字版流程" class="headerlink" title="SpringMvc一次执行的文字版流程"></a>SpringMvc一次执行的文字版流程</h1><p><img src="C:\Users\26411\AppData\Roaming\Typora\typora-user-images\image-20230409123428191.png" alt="image-20230409123428191"></p>
<h1 id="自我描述流程"><a href="#自我描述流程" class="headerlink" title="自我描述流程"></a>自我描述流程</h1><p>1、用户发送请求到前端控制器DispatcherServlet。DispatcherServlet触发service()方法</p>
<p>2、在里面先去找HandlerMapping处理器映射器，匹配到处理这个请求的HandlerMapping（因为有好几种HandlerMapping，最常用的就是RequestMappingHandlerMapping，他就是专门处理@Controller这种请求方法的），并且HandlerMapping会去查找，将匹配到的Handler也就是处理request的方法，和匹配请求路径的拦截器-&gt;拦截器集合，有两者(处理器方法、拦截器集合)—&gt;形成HandlerExecutionChain执行链对象返回给DispatcherSerlvet。</p>
<p>3、然后去找HandlerAdapter处理器适配器，循环几种处理器适配器，匹配找到能解决的这个request的适配器，然后返回HandlerAdapter处理器适配器给DispatcherSerlvet。</p>
<p>4、DispatcherServlet用HandlerExecution执行链对象执行拦截器的前置方法。处理器适配器HandlerAdapter调用最终的handlerMethod处理请求。在处理请求时首先使用方法参数解析器获取请求参数，再使用反射真正的执行目标方法</p>
<p>5、返回ModelAndView。用HandlerExecution执行链对象执行拦截器的后置方法</p>
<p><img src="C:\Users\26411\AppData\Roaming\Typora\typora-user-images\image-20230410191703666.png" alt="image-20230410191703666"></p>
<p>Servlet的生命周期</p>
<ol>
<li>调用 <code>init()</code> 方法初始化</li>
<li>调用 <code>service()</code> 方法来处理客户端的请求</li>
<li>调用 <code>destroy()</code> 方法释放资源，标记自身为可回收</li>
</ol>
<p>每次 Servlet 容器接收到一个 Http 请求， Servlet 容器会产生一个新的线程并调用 Servlet实例的 service 方法。 service 方法会检查 HTTP 请求类型（GET、POST、PUT、DELETE 等），并在适当的时候调用 doGet、doPost、doPut、doDelete 方法。所以，在编码请求处理逻辑的时候，我们只需要关注 doGet()、或doPost()的具体实现即可。</p>
<p><strong>WebApplicationContext就是一个容器。</strong></p>
<p><strong>用spring和springMvc会有两个容器，一个是spring的容器，一个是springMvc的容器。</strong></p>
<p><strong>这两个容器就是IOC容器。</strong></p>
<p><strong>而spring的容器一般存放：service、dao这样的bean。springMvc则存放controller等等和web相关的bean。</strong></p>
<h1 id="DispatcherServlet初始化源码分析"><a href="#DispatcherServlet初始化源码分析" class="headerlink" title="DispatcherServlet初始化源码分析"></a>DispatcherServlet初始化源码分析</h1><p>分析的是DispatchServlet初始化的源码</p>
<p>首先DispatchServlet是一个Servlet，有Servlet的生命周期，首先执行 init() 方法。</p>
<p>init() 方法然后会进入这个方法 initWebApplicationContext()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> WebApplicationContext <span class="title function_">initWebApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">//注意1、rootContext是spring的IOC容器。</span></span><br><span class="line">   <span class="type">WebApplicationContext</span> <span class="variable">rootContext</span> <span class="operator">=</span></span><br><span class="line">         WebApplicationContextUtils.getWebApplicationContext(getServletContext());</span><br><span class="line">   <span class="type">WebApplicationContext</span> <span class="variable">wac</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.webApplicationContext != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// A context instance was injected at construction time -&gt; use it</span></span><br><span class="line">      wac = <span class="built_in">this</span>.webApplicationContext;</span><br><span class="line">      <span class="keyword">if</span> (wac <span class="keyword">instanceof</span> ConfigurableWebApplicationContext cwac &amp;&amp; !cwac.isActive()) &#123;</span><br><span class="line">         <span class="comment">// The context has not yet been refreshed -&gt; provide services such as</span></span><br><span class="line">         <span class="comment">// setting the parent context, setting the application context id, etc</span></span><br><span class="line">         <span class="keyword">if</span> (cwac.getParent() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// The context instance was injected without an explicit parent -&gt; set</span></span><br><span class="line">            <span class="comment">// the root application context (if any; may be null) as the parent</span></span><br><span class="line">            cwac.setParent(rootContext);</span><br><span class="line">         &#125;</span><br><span class="line">         configureAndRefreshWebApplicationContext(cwac);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (wac == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// No context instance was injected at construction time -&gt; see if one</span></span><br><span class="line">      <span class="comment">// has been registered in the servlet context. If one exists, it is assumed</span></span><br><span class="line">      <span class="comment">// that the parent context (if any) has already been set and that the</span></span><br><span class="line">      <span class="comment">// user has performed any initialization such as setting the context id</span></span><br><span class="line">      wac = findWebApplicationContext();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (wac == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 注意点2，当没有spirngMVC容器时，就会去创建一个容器。</span></span><br><span class="line">      <span class="comment">// No context instance is defined for this servlet -&gt; create a local one</span></span><br><span class="line">      wac = createWebApplicationContext(rootContext);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!<span class="built_in">this</span>.refreshEventReceived) &#123;</span><br><span class="line">      <span class="comment">// Either the context is not a ConfigurableApplicationContext with refresh</span></span><br><span class="line">      <span class="comment">// support or the context injected at construction time had already been</span></span><br><span class="line">      <span class="comment">// refreshed -&gt; trigger initial onRefresh manually here.</span></span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="built_in">this</span>.onRefreshMonitor) &#123;</span><br><span class="line">         onRefresh(wac);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.publishContext) &#123;</span><br><span class="line">      <span class="comment">// Publish the context as a servlet context attribute.</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">attrName</span> <span class="operator">=</span> getServletContextAttributeName();</span><br><span class="line">      getServletContext().setAttribute(attrName, wac);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当没有spirngMVC容器时，就会去创建一个容器。进入方法createWebApplicationContext(rootContext)；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> WebApplicationContext <span class="title function_">createWebApplicationContext</span><span class="params">(<span class="meta">@Nullable</span> ApplicationContext parent)</span> &#123;</span><br><span class="line">   Class&lt;?&gt; contextClass = getContextClass();</span><br><span class="line">   <span class="keyword">if</span> (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ApplicationContextException</span>(</span><br><span class="line">            <span class="string">&quot;Fatal initialization error in servlet with name &#x27;&quot;</span> + getServletName() +</span><br><span class="line">            <span class="string">&quot;&#x27;: custom WebApplicationContext class [&quot;</span> + contextClass.getName() +</span><br><span class="line">            <span class="string">&quot;] is not of type ConfigurableWebApplicationContext&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">ConfigurableWebApplicationContext</span> <span class="variable">wac</span> <span class="operator">=</span></span><br><span class="line">         (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line"></span><br><span class="line">   wac.setEnvironment(getEnvironment());</span><br><span class="line">   <span class="comment">// 注意点1：设置Parent 为spring容器。--&gt;父子容器的概念</span></span><br><span class="line">   wac.setParent(parent);</span><br><span class="line">   <span class="type">String</span> <span class="variable">configLocation</span> <span class="operator">=</span> getContextConfigLocation();</span><br><span class="line">   <span class="keyword">if</span> (configLocation != <span class="literal">null</span>) &#123;</span><br><span class="line">      wac.setConfigLocation(configLocation);</span><br><span class="line">   &#125;</span><br><span class="line">   configureAndRefreshWebApplicationContext(wac);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>父子容器的概念。springMvc的IOC容器创建时，指定了spring的IOC容器为父容器（设置了一个parent属性）。</p>
<p>父子容器有什么用？springMvc获取bean时，首先会从SpringMvc的IOC容器中去获取，如果自己的容器没有该bean，会尝试用</p>
<p>getParent()，找到父容器，即spring的IOC容器。再从spring的IOC容器中找bean。</p>
<p>面试题：Spring和SpringMvc的环境都有，在Spring中getBean能不能获取到SpringMvc当中的bean。</p>
<p>是不可以的，因为SpringMvc的IOC容器是Spring的IOC容器的子容器。寻找bean的逻辑是，先从自己的容器找，没有就去找父容器。</p>
<p>并没有找子容器bean的。</p>
<h2 id="总结一"><a href="#总结一" class="headerlink" title="总结一"></a>总结一</h2><p>DispatcherServlet的init()方法。会尝试去创建SpringMvc的IOC容器即（WebApplicationContext）（注意一下，注解方式开发springMvc的IOC容器会已创建，只有Web.xml方式开发才是在这里创建SpringMvc容器）。并且会将Spring的IOC容器设置为SpringMvc的IOC容器的 parent 父容器。</p>
<p>继续分析—————————————–</p>
<p>不论是否创建SpringMvc的容器，都会进入这么一个方法configureAndRefreshWebApplicationContext(wac);</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configureAndRefreshWebApplicationContext</span><span class="params">(ConfigurableWebApplicationContext wac)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (ObjectUtils.identityToString(wac).equals(wac.getId())) &#123;</span><br><span class="line">			<span class="comment">// The application context id is still set to its original default value</span></span><br><span class="line">			<span class="comment">// -&gt; assign a more useful id based on available information</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">this</span>.contextId != <span class="literal">null</span>) &#123;</span><br><span class="line">				wac.setId(<span class="built_in">this</span>.contextId);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// Generate default id...</span></span><br><span class="line">				wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +</span><br><span class="line">						ObjectUtils.getDisplayString(getServletContext().getContextPath()) + <span class="string">&#x27;/&#x27;</span> + getServletName());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		wac.setServletContext(getServletContext());</span><br><span class="line">		wac.setServletConfig(getServletConfig());</span><br><span class="line">		wac.setNamespace(getNamespace());</span><br><span class="line">		wac.addApplicationListener(<span class="keyword">new</span> <span class="title class_">SourceFilteringListener</span>(wac, <span class="keyword">new</span> <span class="title class_">ContextRefreshListener</span>()));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// The wac environment&#x27;s #initPropertySources will be called in any case when the context</span></span><br><span class="line">		<span class="comment">// is refreshed; do it eagerly here to ensure servlet property sources are in place for</span></span><br><span class="line">		<span class="comment">// use in any post-processing or initialization that occurs below prior to #refresh</span></span><br><span class="line">		<span class="type">ConfigurableEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> wac.getEnvironment();</span><br><span class="line">		<span class="keyword">if</span> (env <span class="keyword">instanceof</span> ConfigurableWebEnvironment cwe) &#123;</span><br><span class="line">			cwe.initPropertySources(getServletContext(), getServletConfig());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		postProcessWebApplicationContext(wac);</span><br><span class="line">		applyInitializers(wac);</span><br><span class="line">		wac.refresh();	<span class="comment">// 注意点1：refresh方法</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>进入refresh方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">      <span class="type">StartupStep</span> <span class="variable">contextRefresh</span> <span class="operator">=</span> <span class="built_in">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.refresh&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">      prepareRefresh();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">      <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">         postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="type">StartupStep</span> <span class="variable">beanPostProcess</span> <span class="operator">=</span> <span class="built_in">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.beans.post-process&quot;</span>);</span><br><span class="line">         <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">         invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">         registerBeanPostProcessors(beanFactory);</span><br><span class="line">         beanPostProcess.end();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">         initMessageSource();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">         initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">         onRefresh();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">         registerListeners();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">         finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">         finishRefresh();	<span class="comment">// 注意点1：finishRefresh()</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">         destroyBeans();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">         cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">         <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">         resetCommonCaches();</span><br><span class="line">         contextRefresh.end();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入 finishRefresh()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finishRefresh</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">// Clear context-level resource caches (such as ASM metadata from scanning).</span></span><br><span class="line">   clearResourceCaches();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Initialize lifecycle processor for this context.</span></span><br><span class="line">   initLifecycleProcessor();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Propagate refresh to lifecycle processor first.</span></span><br><span class="line">   getLifecycleProcessor().onRefresh();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Publish the final event.</span></span><br><span class="line">       publishEvent(<span class="keyword">new</span> <span class="title class_">ContextRefreshedEvent</span>(<span class="built_in">this</span>));<span class="comment">// 注意点1：发布刷新完毕的事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要监听了这个事件的监听器，都会收到刷新完成（容器刷新完毕）的通知，进行回调监听器的函数。</p>
<p>执行回调函数时会进入DispatcherServlet的onRefresh()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onRefresh</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">   initStrategies(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入initStrategies(context)方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initStrategies</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">   initMultipartResolver(context);	<span class="comment">// 文件上传解析器</span></span><br><span class="line">   initLocaleResolver(context);</span><br><span class="line">   initThemeResolver(context);</span><br><span class="line">   initHandlerMappings(context);	<span class="comment">// 处理器映射器</span></span><br><span class="line">   initHandlerAdapters(context);	<span class="comment">// 处理器适配器</span></span><br><span class="line">   initHandlerExceptionResolvers(context);</span><br><span class="line">   initRequestToViewNameTranslator(context);</span><br><span class="line">   initViewResolvers(context);		<span class="comment">// 视图解析器</span></span><br><span class="line">   initFlashMapManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，在这里我们看到了初始化HandlerMappings、HandlerAdapters、ViewResolvers等等。</p>
<h2 id="总结二"><a href="#总结二" class="headerlink" title="总结二"></a>总结二</h2><p>DispatcherServlet的init()方法，基于一个监听机制，容器创建完毕后会发一个事件，<strong>在专门监听这个事件的监听器的回调函数</strong>里还会去创建9大组件。其中比较重要的是HandlerMapping处理器映射器、HandlerAdapters处理器适配器、ViewResolvers视图解析器（现在不重要了，现在都是传递json字符串，前后端分离开发）。</p>
<h2 id="初始化-HandlerMappings处理器映射器的源码分析"><a href="#初始化-HandlerMappings处理器映射器的源码分析" class="headerlink" title="初始化  HandlerMappings处理器映射器的源码分析"></a>初始化  HandlerMappings处理器映射器的源码分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initHandlerMappings</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">   <span class="built_in">this</span>.handlerMappings = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.detectAllHandlerMappings) &#123;</span><br><span class="line">      <span class="comment">// Find all HandlerMappings in the ApplicationContext, including ancestor contexts.</span></span><br><span class="line">      Map&lt;String, HandlerMapping&gt; matchingBeans =</span><br><span class="line">            BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">      <span class="comment">// 注意点1：先去spring的IOC容器中找有没有 HandlerMapping.class类型的bean</span></span><br><span class="line">       <span class="keyword">if</span> (!matchingBeans.isEmpty()) &#123;</span><br><span class="line">         <span class="built_in">this</span>.handlerMappings = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(matchingBeans.values());</span><br><span class="line">         <span class="comment">// We keep HandlerMappings in sorted order.</span></span><br><span class="line">         AnnotationAwareOrderComparator.sort(<span class="built_in">this</span>.handlerMappings);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="type">HandlerMapping</span> <span class="variable">hm</span> <span class="operator">=</span> context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping.class);</span><br><span class="line">         <span class="built_in">this</span>.handlerMappings = Collections.singletonList(hm);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">         <span class="comment">// Ignore, we&#x27;ll add a default HandlerMapping later.</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Ensure we have at least one HandlerMapping, by registering</span></span><br><span class="line">   <span class="comment">// a default HandlerMapping if no other mappings are found.</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.handlerMappings == <span class="literal">null</span>) &#123;		<span class="comment">// 注意点2：如果spring的IOC容器中没有HandlerMapping类型bean</span></span><br><span class="line">       <span class="comment">//就会去创建默认策略的HandlerMappings</span></span><br><span class="line">      <span class="built_in">this</span>.handlerMappings = getDefaultStrategies(context, HandlerMapping.class);</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">&quot;No HandlerMappings declared for servlet &#x27;&quot;</span> + getServletName() +</span><br><span class="line">               <span class="string">&quot;&#x27;: using default strategies from DispatcherServlet.properties&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (HandlerMapping mapping : <span class="built_in">this</span>.handlerMappings) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mapping.usesPathPatterns()) &#123;</span><br><span class="line">         <span class="built_in">this</span>.parseRequestPath = <span class="literal">true</span>;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>默认策略的HandlerMappings</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\</span><br><span class="line">   org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping,\</span><br><span class="line">   org.springframework.web.servlet.function.support.RouterFunctionMapping</span><br></pre></td></tr></table></figure>

<p>Spring的IOC容器中的HandlerMapping</p>
<p><img src="C:\Users\26411\AppData\Roaming\Typora\typora-user-images\image-20230424154114347.png" alt="image-20230424154114347"></p>
<p>我们看matchingBeans的</p>
<p>matchingBeans  &lt;String,HandlerMappings&gt; 的 HandlerMappings的   属性MappingRegistry</p>
<p><img src="C:\Users\26411\AppData\Roaming\Typora\typora-user-images\image-20230424182152842.png" alt="image-20230424182152842"></p>
<p><img src="C:\Users\26411\AppData\Roaming\Typora\typora-user-images\image-20230424182505317.png" alt="image-20230424182505317"></p>
<h3 id="总结一-1"><a href="#总结一-1" class="headerlink" title="总结一"></a>总结一</h3><p>我们可以看到当HandlerMappings处理器映射器初始化完成时，已经把 【请求方式、请求路径】作为key。value是一个大对象，其中有一个属性是<strong>handlerMethod</strong>。即对应的处理方法。</p>
<h1 id="DispatcherServlet的执行主流程"><a href="#DispatcherServlet的执行主流程" class="headerlink" title="DispatcherServlet的执行主流程"></a>DispatcherServlet的执行主流程</h1><p>一个Servlet，每次访问时，都会去执行service()方法。</p>
<p>重点：处理器映射器HandlerMapping、处理器适配器HandlerAdapter、处理器Handler、执行链对象HandlerExecutionChain</p>
<p><img src="C:\Users\26411\AppData\Roaming\Typora\typora-user-images\image-20230424184429159.png" alt="image-20230424184429159"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">      <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (HTTP_SERVLET_METHODS.contains(request.getMethod())) &#123;</span><br><span class="line">      <span class="built_in">super</span>.service(request, response);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      processRequest(request, response);<span class="comment">//注意点1	</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后一路走会进入到<strong>doDispatch(request, response)方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   <span class="type">HttpServletRequest</span> <span class="variable">processedRequest</span> <span class="operator">=</span> request;</span><br><span class="line">   <span class="type">HandlerExecutionChain</span> <span class="variable">mappedHandler</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="type">boolean</span> <span class="variable">multipartRequestParsed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">   <span class="type">WebAsyncManager</span> <span class="variable">asyncManager</span> <span class="operator">=</span> WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="type">Exception</span> <span class="variable">dispatchException</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         processedRequest = checkMultipart(request);</span><br><span class="line">         multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Determine handler for the current request.</span></span><br><span class="line">          <span class="comment">// 注意点1： 确定处理当前request请求的  Handler  --&gt; 得到的是   HandlerExecutionChain 执行链对象</span></span><br><span class="line">         mappedHandler = getHandler(processedRequest);</span><br><span class="line">         <span class="keyword">if</span> (mappedHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">            noHandlerFound(processedRequest, response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Determine handler adapter for the current request.</span></span><br><span class="line">          <span class="comment">//注意点2：确定处理当前request请求的 HandlerAdapter 处理器适配器</span></span><br><span class="line">         <span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Process last-modified header, if supported by the handler.</span></span><br><span class="line">         <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethod();</span><br><span class="line">         <span class="type">boolean</span> <span class="variable">isGet</span> <span class="operator">=</span> HttpMethod.GET.matches(method);</span><br><span class="line">         <span class="keyword">if</span> (isGet || HttpMethod.HEAD.matches(method)) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">	</span><br><span class="line">          <span class="comment">// 注意点3：执行拦截器的preHandle方法</span></span><br><span class="line">         <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Actually invoke the handler.</span></span><br><span class="line">          <span class="comment">//注意点4：执行最终的目标handlerMethod </span></span><br><span class="line">         mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         applyDefaultViewName(processedRequest, mv);</span><br><span class="line">          <span class="comment">// 注意点5：执行拦截器的postHandle方法</span></span><br><span class="line">         mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">         dispatchException = ex;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">         <span class="comment">// As of 4.3, we&#x27;re processing Errors thrown from handler methods as well,</span></span><br><span class="line">         <span class="comment">// making them available for @ExceptionHandler methods and other scenarios.</span></span><br><span class="line">         dispatchException = <span class="keyword">new</span> <span class="title class_">ServletException</span>(<span class="string">&quot;Handler dispatch failed: &quot;</span> + err, err);</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="comment">// doDispatch的最终方法</span></span><br><span class="line">      processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">      triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ServletException</span>(<span class="string">&quot;Handler processing failed: &quot;</span> + err, err));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">         <span class="comment">// Instead of postHandle and afterCompletion</span></span><br><span class="line">         <span class="keyword">if</span> (mappedHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">            mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// Clean up any resources used by a multipart request.</span></span><br><span class="line">         <span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">            cleanupMultipart(processedRequest);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="注意点1：进入getHandler方法。-确定处理当前request请求的-Handler-–-gt-得到的是-HandlerExecutionChain-执行链对象"><a href="#注意点1：进入getHandler方法。-确定处理当前request请求的-Handler-–-gt-得到的是-HandlerExecutionChain-执行链对象" class="headerlink" title="注意点1：进入getHandler方法。 确定处理当前request请求的  Handler  –&gt; 得到的是 HandlerExecutionChain 执行链对象"></a>注意点1：进入getHandler方法。 确定处理当前request请求的  Handler  –&gt; 得到的是 HandlerExecutionChain 执行链对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> HandlerExecutionChain <span class="title function_">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.handlerMappings != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (HandlerMapping mapping : <span class="built_in">this</span>.handlerMappings) &#123;</span><br><span class="line">          <span class="comment">// 遍历拥有的几种HandlerMapping ： </span></span><br><span class="line">         <span class="type">HandlerExecutionChain</span> <span class="variable">handler</span> <span class="operator">=</span> mapping.getHandler(request);</span><br><span class="line">          <span class="comment">// 注意点1：getHandler方法里面就会把handler、和匹配拦截路径的Interceptor拦截器都加入到chain执行链里面去</span></span><br><span class="line">         <span class="keyword">if</span> (handler != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> handler;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的this.handlerMappings就是</p>
<p>RequestMappingHandlerMapping、BeanNameUrlHandlerMapping、RouterFunctionMapping</p>
<p><img src="C:\Users\26411\AppData\Roaming\Typora\typora-user-images\image-20230424192743134.png" alt="image-20230424192743134"></p>
<p><strong>最终返回的 HandlerExecutionChain 执行链对象  包括两部分，一部分是拦截器集合。一部分是Handler处理的方法（比如controller的那个方法）-&gt;的抽象。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object handler;	<span class="comment">// 处理request的那个方法的 抽象为handler</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;HandlerInterceptor&gt; interceptorList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//是拦截器集合</span></span><br></pre></td></tr></table></figure>





<h2 id="注意点2：确定处理当前request请求的-HandlerAdapter-处理器适配器"><a href="#注意点2：确定处理当前request请求的-HandlerAdapter-处理器适配器" class="headerlink" title="注意点2：确定处理当前request请求的 HandlerAdapter 处理器适配器"></a>注意点2：确定处理当前request请求的 HandlerAdapter 处理器适配器</h2><p> HandlerAdapter ha &#x3D; getHandlerAdapter(mappedHandler.getHandler());</p>
<p>也是有好几种处理器适配器，分别对应不同的处理器映射器。也是遍历几种处理器适配器，找到适配这个handler的适配器，然后返回这个适配器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> HandlerAdapter <span class="title function_">getHandlerAdapter</span><span class="params">(Object handler)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.handlerAdapters != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (HandlerAdapter adapter : <span class="built_in">this</span>.handlerAdapters) &#123;</span><br><span class="line">         <span class="keyword">if</span> (adapter.supports(handler)) &#123;</span><br><span class="line">            <span class="keyword">return</span> adapter;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>(<span class="string">&quot;No adapter for handler [&quot;</span> + handler +</span><br><span class="line">         <span class="string">&quot;]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="分析注意点3、4、5。"><a href="#分析注意点3、4、5。" class="headerlink" title="分析注意点3、4、5。"></a>分析注意点3、4、5。</h2><p>可以看到执行拦截器的preHandle、postHandle方法都不是靠ha即不是靠HandlerAdapter处理器适配器去执行。而是靠HandlerExecutionChain执行链对象执行的。</p>
<p>只有以下这个执行目标方法HandlerMethod才是ha处理器适配器去调用</p>
<p>​		 &#x2F;&#x2F;注意点4：执行最终的目标handlerMethod<br>​         mv &#x3D; ha.handle(processedRequest, response, mappedHandler.getHandler());</p>
<h2 id="继续分析。"><a href="#继续分析。" class="headerlink" title="继续分析。"></a>继续分析。</h2><p>HandlerAdapter到底怎么执行这个HandlerMethod（即@RestController注解的那个类里的@PostMapping等等对应的那个方法）。</p>
<p>有参数怎么办。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br></pre></td></tr></table></figure>

<p>进入适配器调用handlerMethod的方法   常用的一般是 RequestMappingHandlerAdapter类的 invokeHandlerMethod（）方法</p>
<p>走走走，就会进到invokeForRequest()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invokeForRequest</span><span class="params">(NativeWebRequest request, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">      Object... providedArgs)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">   Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);</span><br><span class="line">   <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(<span class="string">&quot;Arguments: &quot;</span> + Arrays.toString(args));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> doInvoke(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里我们可以看到解析参数的方法显然是   getMethodArgumentValues(request, mavContainer, providedArgs);</p>
<p>得到参数再调用  doInvoke(args)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doInvoke</span><span class="params">(Object... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> getBridgedMethod();</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (KotlinDetector.isSuspendingFunction(method)) &#123;</span><br><span class="line">         <span class="keyword">return</span> invokeSuspendingFunction(method, getBean(), args);</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="comment">//注意点1：使用反射调用目标方法</span></span><br><span class="line">      <span class="keyword">return</span> method.invoke(getBean(), args);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">      assertTargetBean(method, getBean(), args);</span><br><span class="line">      <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> (ex.getMessage() == <span class="literal">null</span> || ex.getCause() <span class="keyword">instanceof</span> NullPointerException) ?</span><br><span class="line">            <span class="string">&quot;Illegal argument&quot;</span> : ex.getMessage();</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(formatInvokeError(text, args), ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">      <span class="comment">// Unwrap for HandlerExceptionResolvers ...</span></span><br><span class="line">      <span class="type">Throwable</span> <span class="variable">targetException</span> <span class="operator">=</span> ex.getCause();</span><br><span class="line">      <span class="keyword">if</span> (targetException <span class="keyword">instanceof</span> RuntimeException runtimeException) &#123;</span><br><span class="line">         <span class="keyword">throw</span> runtimeException;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (targetException <span class="keyword">instanceof</span> Error error) &#123;</span><br><span class="line">         <span class="keyword">throw</span> error;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (targetException <span class="keyword">instanceof</span> Exception exception) &#123;</span><br><span class="line">         <span class="keyword">throw</span> exception;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(formatInvokeError(<span class="string">&quot;Invocation failure&quot;</span>, args), targetException);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><h3 id="Spring-mvc为什么需要HandlerAdapter？"><a href="#Spring-mvc为什么需要HandlerAdapter？" class="headerlink" title="Spring mvc为什么需要HandlerAdapter？"></a>Spring mvc为什么需要HandlerAdapter？</h3><p>处理器适配器 <em>HandlerAdapter</em>:按照特定规则<em>去执行Handler</em>,</p>
<p><em>SpringMvc</em>支持多种处理器,<strong>各种处理器中的处理方法各不相同</strong>,<strong>为了解决适应多种处理器,就出现了处理器适配器</strong>。</p>
<p>因为 SpringMVC 中我们定义 Handler 处理器的方式多种多样（虽然日常开发中我们都是使用注解来定义，但是实际上还有其他方式），</p>
<p><strong>不同的 Handler 当然对应不同的执行方式，</strong>而处理器适配器HandlerAdapter按照特定规则去执行Handler，为了适应多种处理器</p>
<p>Handler，就出现了处理器适配器。所以这中间就需要一个适配器 HandlerAdapter。</p>
<p><strong>设计模式：适配器模式</strong></p>
<p><strong>有很多种控制器(Controller) 一种是带@Controller注解的， 还可以写一个servlet 当做controller，还有beanName方式的控制器，</strong> </p>
<p><strong>所以用适配器做适配</strong>，HandlerAdapter有几个子类，每个子类都是适配某一种类型的控制器，有了HandlerAdapter，</p>
<p><strong>你只需要调用handle方法</strong>，<strong>屏蔽了处理器执行方式不一致的细节</strong>，否则在DispatcherServlet里面要if else if else了</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/24/SpringMvc-1/" data-id="cli18yc930001eca5bodhcxug" data-title="SpringMvc" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2023/05/24/SpringMvc/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">May 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/05/24/SpringMvc-1/">SpringMvc</a>
          </li>
        
          <li>
            <a href="/2023/05/24/SpringMvc/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/05/24/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 HuangWeiGuo<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>